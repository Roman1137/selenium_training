using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace selenium_training._12_Selenium_Extensions
{
    class Superstructures
    {
        //Самый большой класс расширений для Selenium - это надстройки.
        //Роль этих инструментов - повышение удобства использования Selenium.
        //ОНИ улучшают интерфейс клиентских библиотек и устранают недостатки клиентских библиотек.

        //Достаточно редко встречается ситуация, когда кто-то ПОЛНОСТЬЮ переписывает клиентскую библиотеку, делая
        //альтернативную реализацию(это возможно и для языков PHP и JavaScript есть несколько альтернативных реализаций.)

        //Обычно пишется относительно небольшая дополнительная библиотека, которая опирается на стандартную
        //клиентскую библиотеку Selenium и предоставляет альтернативный или может быть более удобный програмный интерфейс
        //к тем же самым функциям, которые уже есть в инструменте Selenium. Слой драйвера при этом соверненно НЕ ЗАТРАГИВАЕТСЯ
        //и все работает точно так же как и раньше.

        //ЗАЧЕМ НУЖНЫ НАДСТРОЙКИ?
        //1.Более удобный интерфейс, чем стандартная библиотека Selenium. В чем заключается неудобство? Selenium предоставляет
        //низкоуровневый примитивный интерфейс и часто возникает желание сделать высокоуровневый интерйфейс,
        //КОТОРЫЙ ПОЗВОЛЯЕТ ПИСАТЬ МЕНЬШЕ ПРОГРАМНОГО КОДА.
        //Клиентские библиотеки на всех 5 языках выглядят примерно одинаково и это плохо. 
        //Стили написания програмного кода на каждом языке - разные. И по этому, для удобвста имеет смысл сделать
        //надстройку, которая реализует интерфейс более приближенный к тому или другому языку программирования.
        //или какой-то ВЕРСИИ ЯП.(стиль написания кода на Java 7 и Java 8 достаточно сильно отличается).
        //Иногда специализация програмного интерфеса связанная с тем, что библиотека НАЦЕЛИВАЕТСЯ НА определнный класс веб приложений.
        //Jquery или AngualJS, или React etc., и там используются дополнительные локаторы, которые характерны именно
        //для этой библиотеки резработки веб приложений.

        //ТАК ИЛИ ИНАЧЕ, ЦЕЛЬ НАДСТРОЕК - СОЗДАНИЕ ПРОГРАМНОГО ИНТЕРФЕЙСА, которые позволит повысить эфективность разработчика тестов.
        //т.е писать меньше кода и писать код быстрее.

        //2.Неявные ожидания или действия. 
        //Например, перед тем как выполнить Click() было бы логичным дожидаться пока элемент станет видимым, или если 
        //клик был неудачным(открылся алерт) - закрыть алерт и кликнуть ещё раз. 
        //Эту функциональность умышленно не хотят делать в Selenium(50:50 разработчиков),
        //аргументируя тем, что это может способствавать упущению багов. 

        //3.Дополнительная функциональность. Например возможности делать скриншоты не всего экрана, а только его части
        //в стандартной библиотеке Selenium но надстройки могут это реализовать: делается скрин всего экрана, а из него
        //"обрезается" скрин нужной части. Или, например скачать файл из сервера можно с помощью надстроек(без proxy).

        //4.Устранение ошибок Selenium. Если тот или иной драйвер выполняет операцию неправильно(пример из жизни- Clear())-
        //то можна использовать какой-то обходной путь. Ещё один пример - скролирование перед тем, как совершить действие с 
        //элементом. Есть такие надстройки, которые САМИ выполняют скролирование, чтобы элемент оказался в видимой части экрана
        //и после этого, сам Selenium скролирование не выполняет.

        //Selenide(Java), Selen (C#)
        //1. Методы  не такие громоздкие, например 
        //вместо driver.FinfElement(By.CssSelector("locator")) просто $("locator")- по умолчанию предполагается, что используются CSS.
        //2. Расширенный набор локаторов - byText, withText, by, byTittle, byValue и т.д- можно это реализовать через XPath и т.д но это БОЛЬШЕ КОДА.
        //3. Selenide - ждет 4 секудны перед действием, если какой-то действие пошло не так, то сразу исключение не выбрасывается,
        //а надстройка пытается сделать ещё попытки, пока действие не завершится успехом либо не закончится таймаут.
        //Есть и сторонники - стабильность в тестах - это хорошо, есть и противники - эт скрывает баги.
        //4. Seleneide умеет снимать скриншоты элементов, загружать файлы из сервера, имеет расширенный набор проверок.
        //5. Есть некоторые функции, которые стандартной библиотеке есть, а в Selenide - нету. Например - StalenessOf,
        //но никто не запрещает использовать "чисты" Selenium когда нужно.

        //Watir (Ruby)
        //1.Сейчас использует движок Selenium внутри. Если использовать стандартную клиентскую библиотеку Selenium для Ruby, то
        //говорят, что вроде как используешь Ruby, а чувство, как буд-то пишешь на Java.
        //Использование надстройки Watir решает эту проблему.
        //В инструменте есть большое количество неявных ожиданый. Более удобное построение локаторов(более удобный поиск элементов).

        //Protractor (JavaScript)
        //1.Написан на JavaScript, но предпринимались попытки миграции на другие языки програмирования (в часности Java).
        //2.Этот инструмент предоставляет специальный програмный интерфейс для тестирования приложений написаной с использование библиотки AngularJS.
        //3.Предоставляет дополнительный набор локаторов: by.model, by.binding - которые характерны имеено для таких приложений -ВНУТРИ, ЭТО ПЕРЕВОДИТСЯ В CSS.
        //4.А так же в этом инструменте есть неявные ожидания, он ждет пока БИБЛЕОТЕКА AngularJS ЗАКОНЧИТ СВОЮ РАБОТУ, т.е действия не выполняются слишком рано.
        //5.Конечно, это можно реализовать с помощью ожиданий связанных с появлением и исчизновением элементов, но прийдется писать больше кода.
        //а значит производительность тестировщика упадет.

        //ИТОГ: если мы не будеть использовать уже готовую надстройку и возьмем простую библиотеку Selenium и будем писать тесты, то
        //рано или поздно у нас получится своя собственная надстрока. И вот здесь нужно попытаться понять, как с моей точки зрения
        //выглядит удобный интерфейс. Если понимаешь, что пилишь то же самое, что уже раилизовано в Selenide, Watir или Protractor
        //имеет смысл остановится и использовать ЭТО готовое решение.
        //Если что-то не устраивает - то это интрументы с открытым исходным кодом => берем код и дописываем того, чего не хватает.
        //Не нужно стеснятся присылать pull request`ы как и в надстройки Selenium`a, так и в Selenium.
    }
}
